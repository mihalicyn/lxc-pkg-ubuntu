From f63d27178ee8180acd0081a18b48200af54c3e52 Mon Sep 17 00:00:00 2001
From: Serge Hallyn <serge.hallyn@ubuntu.com>
Date: Mon, 13 Apr 2015 21:19:47 +0000
Subject: lxc-cmd-stop: two fixes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

These are two fixes for long, long-standing bugs.

1. When we stop a container from the lxc_cmd stop handler, we kill its
init task, then we unfreeze the container to make sure it receives the
signal.  When that unfreeze succeeds, we were immediately returning 0,
without sending a response to the invoker.

2. lxc_cmd returns the length of the field received.  In the case of
an lxc_cmd_stop this is 16.  But a comment claims we expect no response,
only a 0.  In fact the handler does send a response, which may or may
not include an error.  So don't call an error just because we got back a
response.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: St√©phane Graber <stgraber@ubuntu.com>
---
 src/lxc/commands.c | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/src/lxc/commands.c b/src/lxc/commands.c
index b70ee72..c2354af 100644
--- a/src/lxc/commands.c
+++ b/src/lxc/commands.c
@@ -608,11 +608,13 @@ int lxc_cmd_stop(const char *name, const char *lxcpath)
 		return -1;
 	}
 
-	/* we do not expect any answer, because we wait for the connection to be
-	 * closed
-	 */
-	if (ret > 0) {
-		ERROR("failed to stop '%s': %s", name, strerror(-cmd.rsp.ret));
+	if (!ret) {
+		WARN("'%s' has stopped before replying with success", name);
+		return -1;
+	}
+
+	if (cmd.rsp.ret != 0) {
+		ERROR("Container %s:%s had an error stopping", lxcpath, name);
 		return -1;
 	}
 
@@ -637,11 +639,12 @@ static int lxc_cmd_stop_callback(int fd, struct lxc_cmd_req *req,
 		 * deadlock us
 		 */
 		if (cgroup_unfreeze(handler))
-			return 0;
+			goto out;
 		ERROR("Failed to unfreeze %s:%s", handler->lxcpath, handler->name);
 		rsp.ret = -1;
 	}
 
+out:
 	return lxc_cmd_rsp_send(fd, &rsp);
 }
 
