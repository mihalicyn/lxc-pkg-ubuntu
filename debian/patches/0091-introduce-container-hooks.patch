From 05a2c6f3cff93e07dd197b2e12244ec62a9450fb Mon Sep 17 00:00:00 2001
From: Ubuntu <ubuntu@server-12459.canonistack>
Date: Fri, 15 Jun 2012 21:57:57 +0000
Subject: [PATCH 1/1] Introduce a first set of container hooks

This patch introduces support for 4 hooks.  We'd like to have 6 in
all to mirror the openvz ones (thanks to stgraber for pursuing this info):

pre-start: in the host namespace before container mounting happens
mount: after container mounting (as per config and /var/lib/lxc/container/fstab)
       but before pivot_root
start: immediately before exec'ing init
stop: in container namespace and in chroot before shutdown
umount: after other unmounting has happened
post-stop: outside of the container

stop and umount are not possible because when the kernel kills the
container init, it kills the namespace.  (we can probably work around
this, i.e. by keeping the /proc/pid/ns/mnt open, and using that,
though all container tasks including init would still be dead).

start also presents a bit of an issue.  openvz allows a script on
the host to be specified, apparently.  My patch simply requires the
script or program to exist in the container.  I'm fine with trying
to do it the openvz way, but I wasn't sure what the best way to do
that was.  Openvz (I'm told) opens the script and passes its contents
to a bash in the container.  But that limits the hooks to being only
scripts.

Other than that,

lxc.hook.pre-start = /var/lib/lxc/p1/pre-start
lxc.hook.mount = /var/lib/lxc/p1/mount
lxc.hook.start = /start
lxc.hook.post-stop = /var/lib/lxc/p1/post-stop

is working for me.  Comments on the patch, the hooks we want, and
the questions raised above would be appreciated.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
---
 src/lxc/conf.c    |   29 +++++++++++++++++++++++++++++
 src/lxc/conf.h    |   12 ++++++++++++
 src/lxc/confile.c |   40 ++++++++++++++++++++++++++++++++++++++++
 src/lxc/start.c   |    6 ++++++
 4 files changed, 87 insertions(+)

Index: bug-1017862/src/lxc/conf.c
===================================================================
--- bug-1017862.orig/src/lxc/conf.c	2012-06-26 09:56:08.662575000 -0500
+++ bug-1017862/src/lxc/conf.c	2012-06-26 15:17:04.105611238 -0500
@@ -1689,6 +1689,7 @@
 struct lxc_conf *lxc_conf_init(void)
 {
 	struct lxc_conf *new;
+	int i;
 
 	new = 	malloc(sizeof(*new));
 	if (!new) {
@@ -1710,6 +1711,8 @@
 	lxc_list_init(&new->mount_list);
 	lxc_list_init(&new->caps);
 	new->aa_profile = NULL;
+	for (i=0; i<NUM_LXC_HOOKS; i++)
+		lxc_list_init(&new->hooks[i]);
 
 	return new;
 }
@@ -2186,6 +2189,7 @@
 		ERROR("failed to setup the cgroups for '%s'", name);
 		return -1;
 	}
+	HOOK(name, "mount", lxc_conf);
 
 	if (setup_console(&lxc_conf->rootfs, &lxc_conf->console, lxc_conf->ttydir)) {
 		ERROR("failed to setup the console for '%s'", name);
@@ -2238,3 +2242,28 @@
 
 	return 0;
 }
+
+int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf)
+{
+	int which = -1;
+	struct lxc_list *it;
+
+	if (strcmp(hook, "pre-start") == 0)
+		which = LXCHOOK_PRESTART;
+	else if (strcmp(hook, "mount") == 0)
+		which = LXCHOOK_MOUNT;
+	else if (strcmp(hook, "start") == 0)
+		which = LXCHOOK_START;
+	else if (strcmp(hook, "post-stop") == 0)
+		which = LXCHOOK_POSTSTOP;
+	else
+		return -1;
+	lxc_list_for_each(it, &conf->hooks[which]) {
+		int ret;
+		char *hookname = it->elem;
+		ret = run_script(name, "lxc", hookname, hook, NULL);
+		if (ret)
+			return ret;
+	}
+	return 0;
+}
Index: bug-1017862/src/lxc/conf.h
===================================================================
--- bug-1017862.orig/src/lxc/conf.h	2012-06-26 09:56:08.662575000 -0500
+++ bug-1017862/src/lxc/conf.h	2012-06-26 13:03:58.677431734 -0500
@@ -200,6 +200,9 @@
  * @ttydir     : directory (under /dev) in which to create console and ttys
  * @aa_profile : apparmor profile to switch to
  */
+enum lxchooks {
+	LXCHOOK_PRESTART, LXCHOOK_MOUNT, LXCHOOK_START,
+	LXCHOOK_POSTSTOP, NUM_LXC_HOOKS};
 struct lxc_conf {
 	char *fstab;
 	int tty;
@@ -219,8 +222,16 @@
 	int close_all_fds;
 	char *aa_profile;
 	int umount_proc;
+	struct lxc_list hooks[NUM_LXC_HOOKS];
 };
 
+int run_lxc_hooks(const char *name, char *hook, struct lxc_conf *conf);
+#define HOOK(name, which, conf) \
+	do { \
+		int hookret = run_lxc_hooks(name, which, conf); \
+		if (hookret) return -1; \
+	} while (0);
+
 /*
  * Initialize the lxc configuration structure
  */
Index: bug-1017862/src/lxc/confile.c
===================================================================
--- bug-1017862.orig/src/lxc/confile.c	2012-06-26 09:56:08.662575000 -0500
+++ bug-1017862/src/lxc/confile.c	2012-06-26 13:03:58.677431734 -0500
@@ -56,6 +56,7 @@
 static int config_rootfs_mount(const char *, char *, struct lxc_conf *);
 static int config_pivotdir(const char *, char *, struct lxc_conf *);
 static int config_utsname(const char *, char *, struct lxc_conf *);
+static int config_hook(const char *key, char *value, struct lxc_conf *lxc_conf);
 static int config_network_type(const char *, char *, struct lxc_conf *);
 static int config_network_flags(const char *, char *, struct lxc_conf *);
 static int config_network_link(const char *, char *, struct lxc_conf *);
@@ -93,6 +94,10 @@
 	{ "lxc.rootfs",               config_rootfs               },
 	{ "lxc.pivotdir",             config_pivotdir             },
 	{ "lxc.utsname",              config_utsname              },
+	{ "lxc.hook.pre-start",       config_hook                 },
+	{ "lxc.hook.mount",           config_hook                 },
+	{ "lxc.hook.start",           config_hook                 },
+	{ "lxc.hook.post-stop",       config_hook                 },
 	{ "lxc.network.type",         config_network_type         },
 	{ "lxc.network.flags",        config_network_flags        },
 	{ "lxc.network.link",         config_network_link         },
@@ -584,6 +589,41 @@
 	SYSERROR("Unknown key: %s", key);
 	free(copy);
 	return -1;
+}
+
+static int add_hook(struct lxc_conf *lxc_conf, int which, char *hook)
+{
+	struct lxc_list *hooklist;
+
+	hooklist = malloc(sizeof(*hooklist));
+	if (!hooklist) {
+		free(hook);
+		return -1;
+	}
+	hooklist->elem = hook;
+	lxc_list_add_tail(&lxc_conf->hooks[which], hooklist);
+	return 0;
+}
+
+static int config_hook(const char *key, char *value,
+				 struct lxc_conf *lxc_conf)
+{
+	char *copy = strdup(value);
+	if (!copy) {
+		SYSERROR("failed to dup string '%s'", value);
+		return -1;
+	}
+	if (strcmp(key, "lxc.hook.pre-start") == 0)
+		return add_hook(lxc_conf, LXCHOOK_PRESTART, copy);
+	else if (strcmp(key, "lxc.hook.mount") == 0)
+		return add_hook(lxc_conf, LXCHOOK_MOUNT, copy);
+	else if (strcmp(key, "lxc.hook.start") == 0)
+		return add_hook(lxc_conf, LXCHOOK_START, copy);
+	else if (strcmp(key, "lxc.hook.post-stop") == 0)
+		return add_hook(lxc_conf, LXCHOOK_POSTSTOP, copy);
+	SYSERROR("Unknown key: %s", key);
+	free(copy);
+	return -1;
 }
 
 static int config_personality(const char *key, char *value,
Index: bug-1017862/src/lxc/start.c
===================================================================
--- bug-1017862.orig/src/lxc/start.c	2012-06-26 09:56:08.662575000 -0500
+++ bug-1017862/src/lxc/start.c	2012-06-26 13:03:58.681431734 -0500
@@ -360,6 +360,8 @@
 		goto out_free_name;
 	}
 
+	HOOK(name, "pre-start", conf);
+
 	if (lxc_create_tty(name, conf)) {
 		ERROR("failed to create the ttys");
 		goto out_aborting;
@@ -404,6 +406,8 @@
 	lxc_set_state(name, handler, STOPPING);
 	lxc_set_state(name, handler, STOPPED);
 
+	HOOK(name, "post-stop", handler->conf);
+
 	/* reset mask set by setup_signal_fd */
 	if (sigprocmask(SIG_SETMASK, &handler->oldmask, NULL))
 		WARN("failed to restore sigprocmask");
@@ -585,6 +589,8 @@
 
 	close(handler->sigfd);
 
+	HOOK(handler->name, "start", handler->conf);
+
 	/* after this call, we are in error because this
 	 * ops should not return as it execs */
 	if (handler->ops->start(handler, handler->data))
