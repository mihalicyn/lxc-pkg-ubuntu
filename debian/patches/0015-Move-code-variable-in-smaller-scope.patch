From a6ff0a8314a4e6c8529f4fdf6ceb89b641b03790 Mon Sep 17 00:00:00 2001
From: Rachid Koucha <47061324+Rachid-Koucha@users.noreply.github.com>
Date: Sat, 29 Jun 2019 23:21:14 +0200
Subject: Move code/variable in smaller scope

In start.c, do not fill path[] table if not necessary

Signed-off-by: Rachid Koucha <rachid.koucha@gmail.com>
---
 src/lxc/start.c | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/src/lxc/start.c b/src/lxc/start.c
index 720b3bced..155b91ae5 100644
--- a/src/lxc/start.c
+++ b/src/lxc/start.c
@@ -1113,7 +1113,6 @@ static int do_start(void *data)
 	ATTR_UNUSED __do_close_prot_errno int data_sock0 = handler->data_sock[0],
 					      data_sock1 = handler->data_sock[1];
 	int ret;
-	char path[PATH_MAX];
 	uid_t new_uid;
 	gid_t new_gid;
 	struct lxc_list *iterator;
@@ -1220,11 +1219,6 @@ static int do_start(void *data)
 		goto out_warn_father;
 	}
 
-	ret = snprintf(path, sizeof(path), "%s/dev/null",
-		       handler->conf->rootfs.mount);
-	if (ret < 0 || ret >= sizeof(path))
-		goto out_warn_father;
-
 	/* In order to checkpoint restore, we need to have everything in the
 	 * same mount namespace. However, some containers may not have a
 	 * reasonable /dev (in particular, they may not have /dev/null), so we
@@ -1236,6 +1230,13 @@ static int do_start(void *data)
 	 * where it isn't wanted.
 	 */
 	if (handler->daemonize && !handler->conf->autodev) {
+		char path[PATH_MAX];
+		
+		ret = snprintf(path, sizeof(path), "%s/dev/null",
+			       handler->conf->rootfs.mount);
+		if (ret < 0 || ret >= sizeof(path))
+			goto out_warn_father;
+		
 		ret = access(path, F_OK);
 		if (ret != 0) {
 			devnull_fd = open_devnull();
