Description: fix lxc-clone handling of blockdev names for lvm
 This appears to have been introduced in a bad combination of divergent
 upstream commits.
 Since upstream has replaced the script with a c program using the
 new API clone function, this is only applicable to raring and saucy.
Author: Serge Hallyn <serge.hallyn@ubuntu.com>
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1183354
Forwarded: no

Index: lxc-0.9.0/src/lxc/lxc-clone.in
===================================================================
--- lxc-0.9.0.orig/src/lxc/lxc-clone.in	2013-04-05 04:45:22.000000000 -0500
+++ lxc-0.9.0/src/lxc/lxc-clone.in	2013-05-23 14:20:31.812410661 -0500
@@ -211,41 +211,44 @@
     if [ $lxc_size = "_unset" ]; then
         lxc_size=`lvdisplay $oldroot | grep Size | awk '{ print $3 $4 }'`
     fi
-    newlv="${lxc_lv_prefix}${lxc_new}_snapshot"
-    lvcreate -s -L $lxc_size -n $newlv $oldroot
+    snaplv="${lxc_lv_prefix}${lxc_new}_snapshot"
+    lvcreate -s -L $lxc_size -n $snaplv $oldroot
     which xfs_admin > /dev/null 2>&1 && {
         # change filesystem UUID if it is an xfs filesystem
-        xfs_admin -u /dev/$lxc_vg/$newlv && xfs_admin -U generate /dev/$lxc_vg/$newlv
+        xfs_admin -u /dev/$lxc_vg/$snaplv > /dev/null 2>&1 && xfs_admin -U generate /dev/$lxc_vg/$snaplv
     }
 
+    rootfs_mount=$lxc_path/$lxc_new/rootfs
     if [ $container_running = "True" ]; then
         lxc-unfreeze -n $lxc_orig
         frozen=0
     fi
     if [ $snapshot = "no" ]; then
         #mount snapshot
-        mkdir -p ${rootfs}_snapshot
-        mount /dev/$lxc_vg/${lxc_lv_prefix}${lxc_new}_snapshot ${rootfs}_snapshot || { echo "$(basename $0): failed to mount new rootfs_snapshot" >&2; false; }
+        mkdir -p ${rootfs_mount}_snapshot
+        mount /dev/$lxc_vg/$snaplv ${rootfs_mount}_snapshot || { echo "$(basename $0): failed to mount new rootfs_snapshot" >&2; false; }
         #create a new lv
         lvcreate -L $lxc_size $lxc_vg -n ${lxc_lv_prefix}$lxc_new
-        echo "lxc.rootfs = /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new" >> $lxc_path/$lxc_new/config
         # and mount it so we can tweak it
-        mkdir -p $rootfs
+        mkdir -p $rootfs_mount
         mkfs -t $fstype /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new
-        mount /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new $rootfs || { echo "$(basename $0): failed to mount new rootfs" >&2; false; }
+        mount /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new $rootfs_mount || { echo "$(basename $0): failed to mount new rootfs" >&2; false; }
         mounted=1
-        rsync -Hax ${rootfs}_snapshot/ ${rootfs}/ || { echo "$(basename $0): copying data to new lv failed" >&2; false; }
-        umount ${rootfs}_snapshot
-        rmdir ${rootfs}_snapshot
-        lvremove -f $lxc_vg/${lxc_lv_prefix}${lxc_new}_snapshot
+        rsync -Hax ${rootfs_mount}_snapshot/ ${rootfs_mount}/ || { echo "$(basename $0): copying data to new lv failed" >&2; false; }
+        umount ${rootfs_mount}_snapshot
+        rmdir ${rootfs_mount}_snapshot
+        lvremove -f /dev/$lxc_vg/${lxc_lv_prefix}${lxc_new}_snapshot
     else
-        lvrename $lxc_vg/${lxc_lv_prefix}${lxc_new}_snapshot $lxc_vg/${lxc_lv_prefix}$lxc_new
-        echo "lxc.rootfs = /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new" >> $lxc_path/$lxc_new/config
+        lvrename $lxc_vg/$snaplv $lxc_vg/${lxc_lv_prefix}$lxc_new
         # and mount it so we can tweak it
-        mkdir -p $rootfs
-        mount /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new $rootfs || { echo "$(basename $0): failed to mount new rootfs" >&2; false; }
+        mkdir -p $rootfs_mount
+        mount /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new $rootfs_mount || { echo "$(basename $0): failed to mount new rootfs" >&2; false; }
         mounted=1
     fi
+    echo "lxc.rootfs = /dev/$lxc_vg/${lxc_lv_prefix}$lxc_new" >> $lxc_path/$lxc_new/config
+    # lvm calls rootfs the device and rootfs_mount the mount path.  But after
+    # this point the script uses $rootfs.  Just assign.  This script is dying soon.
+    rootfs=$rootfs_mount
 
 elif which btrfs >/dev/null 2>&1 && btrfs subvolume list $oldroot >/dev/null 2>&1; then
     # if oldroot is a btrfs subvolume, assume they want a snapshot
